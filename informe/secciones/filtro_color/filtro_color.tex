\subsection{Descripción del filtro}

El filtro de color es una transformación sobre imágenes a color que tiene el efecto de decolorizar o pasar a escala de grises todos los píxeles de la entrada cuyo color no esté dentro de un rango de colores especificado. En la figura \ref{fig:filtro-color-ejemplo} se observa un ejemplo de funcionamiento típico.

\begin{figure}[h]
\begin{center}
  \includegraphics[scale=0.4]{secciones/filtro_color/imagenes/matecocido.jpg}
  \includegraphics[scale=0.4]{secciones/filtro_color/imagenes/matecocido-fcolor.jpg}
\end{center}
\caption{Imagen antes y después de aplicar el filtro de color con color principal rojo.}
\label{fig:filtro-color-ejemplo}
\end{figure}

La forma en la cual se especifica el rango de colores que deberá permanecer inmutado es mediante la elección de un color principal, cuya codificación RGB se denota con (\param{rc}, \param{gc}, \param{bc}), y un parámetro umbral \param{threshold}. Una vez determinados estos valores, un píxel de la imagen fuente será actualizado por el filtro únicamente si cumple:


\begin{equation} \label{filtro-color-condicion}
\vectornorm{(r, g, b) - (rc, gc, bc)} > threshold 
\end{equation}

donde (\param{r}, \param{g}, \param{b}) es la codificación en RGB del píxel. En particular, de cumplirse esta condición, los tres canales se actualizan de la siguiente forma:

$$ r' = b' = g' = \frac{r + g + b}{3} $$

De esta última expresión se desprende que el color de los píxeles alterados pasa a estar en la escala de grises, ya que los tres canales toman igual valor. Como una observación adicional, queda claro mediante esta especificación que el filtro actúa de forma localizada en sobre cada píxel; su suceptibilidad a ser modificado y su nuevo valor dependen únicamente de su propio valor, y no del de sus vecinos.

\subsection{Implementación en lenguaje C y lenguaje ensamblador}

La implementación en C del filtro se realizó de la forma más sencilla e intuitiva posible; mediante un ciclo que visita una vez a cada píxel de la imagen, de izquierda a derecha y de arriba a abajo, evaluando la condición y modificando su valor de ser necesario. Como única optimización elemental, se modificó la condición (\ref{filtro-color-condicion}) por la siguiente condición equivalente:

$$\vectornorm{(r, g, b) - (rc, gc, bc)}^2 = (r - rc)^2 + (g - gc)^2 + (b - bc)^2 > threshold^2$$

La modificación evita el cálculo de una raíz cuadrada, sin incurrir en el riesgo de exceder el rango del tipo de datos utilizado ya que el máximo \param{threshold} que no hace a la condición trivialmente falsa es $\sqrt{195075} \approx 441$ (el valor máximo que puede tomar la expresión de la izquierda es $255^2 + 255^2 + 255^2 = 195075$), por lo que cualquier valor mayor se puede reducir a $442$.

La implementación en lenguaje ensamblador mantiene esencialmente el mismo procedimiento, con la salvedad de que fue adaptado para procesar cuatro píxeles en simultáneo mediante el uso de operaciones SIMD. Se recorre la matriz en el mismo órden descripto previamente, realizando lecturas de 16 bytes por iteración (equivalente a 5 píxeles y un byte sobrante).

La necesidad de limitar el procesamiento simultáneo a cuatro píxeles se desprende del hecho de que, como se dijo antes, la expresión que mide la distancia entre un píxel y el color principal puede tomar valores en el rango $0, ... \,195075$. Este último valor no cabe en un entero de 16 bits, precisándose un \tipo{double word} para almacenar ese resultado temporal; esto implica un total de hasta cuatro valores de distancia en un registro XMM. En cuestiones de espacio, hubiese sido equivalente utilizar \tipo{floats} ya que también caben hasta cuatro por registro de 128 bits.

De esta forma, el procedimiento realizado en cada iteración consiste en (para cada uno de los cuatro píxeles en simultáneo) comparar el valor de la distancia con el \param{threshold}, y calcular el promedio de los tres canales, actualizando luego sus valores según la siguiente expresión informal:

$$\text{valor\_original} \land \lnot \text{cumple\_condicion} + \text{promedio} \land \text{cumple\_condicion}$$

Esto permite expresar el equivalente a una expresión del tipo \textbf{if}-\textbf{then}-\textbf{else}, en el lenguaje del procesamiento simultáneo. El cómputo de los flags con el resultado de las comparaciones y del promedio se puede describir mediante el pseudo-código de la figura \ref{fig:pseudocodigo-filtro-color}.

\begin{figure}[h]
	\begin{mdframed}
	\begin{center}
		\begin{lstlisting}
		prom := [0,0,0,0] 			// enteros doubleword
		dist := [0,0,0,0]
	
		desempaquetar el rojo de cada pixel a un double word
		rojos := [r4, r3, r2, r1]
	
		prom += rojos
		rojos -= [rc, rc, rc, rc]
		rojos *= rojos
		dist += rojos
	
		repetir para verdes
		repetir para azules
	
		prom := prom / 3
		dist := dist > [threshold, threshold, threshold, threshold]
		empaquetar prom y dist a formato pixeles

		resultado := datos AND NOT dist
		resultado += prom AND dist
		\end{lstlisting}
	\end{center}
	\end{mdframed}
	\caption{Pseudo-código de la implementación en lenguaje ensablador del filtro color.}
	\label{fig:pseudocodigo-filtro-color}
\end{figure}

Para la correcta implementación de este procedimiento es importante contemplar el caso excepcional que sucede en la última iteración, cuando falta procesar los últimos cuatro píxeles de la imagen. De realizarse una lectura desde el comienzo del píxel, se leería junto a los píxeles restantes un total de 4 bytes de memoria posteriores al fin de la imagen. Por esta razon, la última iteración se dejó fuera del ciclo principal, realizando un retroceso de 4 bytes en el puntero de lectura, y ejecutando una versión levemente modificada del cuerpo de ciclo de forma tal que procese los píxeles en los últimos 12 bytes del registro, en vez de los primeros.

\subsection{Optimizaciones en código C}
\label{sub:filtro-color-optimizaciones-c}

El código de la implementación en lenguaje C se compiló con los distintos flags de optimización descriptos en la sección \ref{}. Los resultados en cuestión de performance se pueden ver en la figura \ref{}, la cual muestra una comparación entre la cantidad de clocks consumidos durante la ejecución de cada versión.

TODO:: Discutir un poco la figura.

Adicionalmente, se analizaron las diferencias entre el código generado con compilación estándar y el código generado con optimización de tipo O1. La diferencia entre ambos evidencia inmediatamente una característica subóptima del código estándar; \emph{todas} las variables locales se alojan en la pila, incluso habiendo disponibilidad de registros. Los registros se utilizan únicamente como variables temporales, y al final de cada extracto de código se guarda el resultado en un espacio de la pila. El código generado con O1, en cambio, ahorra gran cantidad de esos accesos a memoria. Este comportamiento se ejemplifica con el siguiente extracto (figura \ref{fig:codigo-objeto-filtro-color}).

% esto está atado con alambre...
\begin{figure}[h]
	\begin{mdframed}
	\begin{center}
		\begin{lstlisting}
		mov  eax, DWORD PTR[rbp-0x10]	| imul   r15d,r15d
		mov  edx,eax			| imul   r14d,r14d
		imul edx, DWORD PTR[rbp-0x10]	| add    r14d,r15d
		mov  eax, DWORD PTR[rbp-0xc]	| imul   ebx,ebx
		imul eax, DWORD PTR[rbp-0xc]	| add    ebx,r14d
		add  edx,eax			|			
		mov  eax, DWORD PTR[rbp-0x8]	|			
		imul eax, DWORD PTR[rbp-0x8]	|			
		add  eax,edx			|			
		mov  DWORD PTR [rbp-0x4],eax	|			
		\end{lstlisting}
	\end{center}
	\end{mdframed}
	\caption{Código objeto generado con compilación por default (izquierda), y con optimización de tipo O1 (derecha).}
	\label{fig:codigo-objeto-filtro-color}
\end{figure}

Sin embargo, la lógica de flujo del código generado es equivalente. Es decir, las operaciones realizadas y el orden en que se realizan son iguales; se mantiene la forma de recorrer la imagen y el procesamiento píxel por píxel.

\subsection{Optimización en código ASM - Desenrollado de ciclos}
\label{sub:filtro-color-optimizaciones-asm}

Sobre la implementación en lenguaje ensamblador ya descripta, se realizaron dos sucesivas modificaciones para estudiar la técnica conocida como desenrollado de ciclos.

% Describir ocmo funciona el filtro.	
% Como se implementó en c
% Cómo se implementó en asm
	% - explicar el algorítmo
	% - explicar el caso borde
	% - explicar las optimizaciones realizadas. Loop unrolling.
	% - particularidades del filtro. Div 3. Se hicieron todas las cuentas con ints pero al final hubo que pasar a float para poder dividir por 3.
%--Gráfico--  (Performance)
% C vs ASM
% C vs O1, O2, O3
% ASM vs loop unrolling x2 vs loop unrolling 4
% C con y sin condicionales


% Comparar estructura en c y en asm.
	% - En c es un loop que procesa un pixel por vez con un condicional adentro (lo que hace tarde distinta cantidad de tiempo para distintas imágenes).
	% - En asm procesa de a 4 pixeles por vez y hace el mismo proceso independientemente de la imagen.
	% - ¿Que pesa más?¿Procesamiento o acceso a memoria?
	% - Diferencias estructurales
		% - Comparación líneas de código


